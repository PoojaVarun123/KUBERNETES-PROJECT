=======================================================================================================
Basic Kubernetes (without service mesh):default
=======================================================================================================
Traffic splitting is replica-based: You control traffic by scaling the number of pods for each version.
The Service does random load-balancing across all matching pods.

âœ… In plain Kubernetes (without Istio or Service Mesh), Canary Deployment is done using replica count and 
labelsâ€”no actual â€œtraffic splittingâ€ control, but it works in real-time production environments.
---------------------------------------------------------------------------------------------------------
ğŸš€ Real-Time Canary Deployment in Plain Kubernetes (Replica-Based)
âœ… Key Idea:
Create two Deployments (old + new version) with:
The same Service selector (app: my-app)
Different version labels (version: v1 and version: v2)

Control traffic by adjusting pod replica counts.
--------------------------------------------------------------------------------------------------------
ğŸ“„ Step 1: Service (Shared for All Versions)
apiVersion: v1
kind: Service
metadata:
  name: my-app-service
  namespace: production
spec:
  selector:
    app: my-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080

âœ… Service routes traffic to any pod with label app: my-app.
---------------------------------------------------------------------------------------------------------
ğŸ“„ Step 2: Old Deployment (v1)

apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app-v1
  namespace: production
spec:
  replicas: 4
  selector:
    matchLabels:
      app: my-app
      version: v1
  template:
    metadata:
      labels:
        app: my-app
        version: v1
    spec:
      containers:
      - name: my-app
        image: myrepo/my-app:v1
        ports:
        - containerPort: 8080
---------------------------------------------------------------------------------------------------------
ğŸ“„ Step 3: Canary Deployment (v2)

apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app-v2
  namespace: production
spec:
  replicas: 1   # Start with 1 pod for canary
  selector:
    matchLabels:
      app: my-app
      version: v2
  template:
    metadata:
      labels:
        app: my-app
        version: v2
    spec:
      containers:
      - name: my-app
        image: myrepo/my-app:v2
        ports:
        - containerPort: 8080
---------------------------------------------------------------------------------------------------------
âœ… Now: | Version | Number of Pods | Approx Traffic | 
        | v1      | 4 pods         | ~80%           | 
        | v2      | 1 pod (canary) | ~20%           |
Kubernetes Service does random selection, so traffic is split proportionally to pod counts.
---------------------------------------------------------------------------------------------------------
ğŸ“ˆ Step 4: Gradually Increase v2:
kubectl scale deployment my-app-v2 --replicas=3 -n production
ğŸ‘‰ You can progressively increase:
v2: 1 â†’ 3 â†’ 5 pods
v1: Reduce from 4 â†’ 2 â†’ 0 pods
---------------------------------------------------------------------------------------------------------
ğŸ›‘ Rollback:
kubectl scale deployment my-app-v2 --replicas=0 -n production
# Or delete v2:
kubectl delete deployment my-app-v2 -n production
---------------------------------------------------------------------------------------------------------
âœ… Summary: Plain Kubernetes Canary Pros & Cons
Pros/Cons
âœ… Simple (no service mesh needed) âŒ No fine-grained % traffic control
âœ… Easy to rollback or scale up/down âŒ Random pod selection by Service
âœ… Works with just kubectl & YAML âŒ No session stickiness, no progressive traffic shift

ğŸ‘‰ Production Tip:
Monitor canary pods via:
kubectl get pods -l version=v2 -n production
kubectl logs deployment/my-app-v2 -n production
If stable â†’ scale up
If issues â†’ rollback fast.
========================================================================================================
ğŸ‘‰ In advanced production (with service mesh like Istio, Linkerd, or AWS App Mesh):
You control traffic splitting explicitly through YAML (VirtualService in Istio, for example).
=======================================================================================================
With Istio, you can precisely define % of traffic to each version in YAML using a VirtualService.

1) Istio VirtualService
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: my-app-virtualservice
  namespace: production
spec:
  hosts:
  - my-app.example.com
  http:
  - route:
    - destination:
        host: my-app
        subset: v1
      weight: 80
    - destination:
        host: my-app
        subset: v2
      weight: 20
--------------------------------------------------------------------------------------------------------------
2) DestinationRule to define subsets:
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: my-app-destination
  namespace: production
spec:
  host: my-app
  subsets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2

2. Your Deployments must have these labels:
metadata:
  labels:
    app: my-app
    version: v1   # or v2

âœ… Result:
80% of traffic â†’ Pods with label version: v1
20% of traffic â†’ Pods with label version: v2
No matter how many replicas you haveâ€”actual request traffic is split by Istio.

====================================================================================
